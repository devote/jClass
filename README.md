RefineJS
========

#### Мощный и гибкий генератор объектов с возможностью наследования

---
Эта мини-библиотека добавляет/расширяет возможности для объектов в JavaScript или если быть точнее, делает всю рутинную работу над объектами за вас. А именно:

  + **Кросс-браузерность**
    -  Вам не нужно задумываться о проблемах реализации в разных браузерах, библиотека об этом подумает и сделает за вас.


  + **Инкапсуляция**
    -  Позволяет объединить данные и методы, работающие с ними в пределах объекта, и скрыть детали реализации от пользователя.


  + **Методы доступа**
    -  Для доступа к находящимся в полях данным используются специальные методы, называемые методами доступа. Такие методы либо возвращают значение того или иного поля, либо производят запись в это поле нового значения.
    > Создают ряд ограничений в Internet Explorer 8 и более ранних версиях. Подробнее об ограничениях будет описано в главе "**Создание методов доступа**".


  + **Расширение/Переопределение**
    -  Позволяет расширить/переопределить функционал или возможности уже существующих объектов. Данная возможность удобна например для HTML-элементов, которые нуждаются в каких-либо дополнениях/изменениях. 


  + **Наследование (прототипирование)**
    -  Обычное прототипное наследование одного объекта от другого объекта.


  + **Виртуальное наследование**
    -  Один из вариантов множественного наследования, хотя больше схожее с примесями. Не является важной частью библиотеки, данная возможность реализована скорее для полноты (простыми словами "на всякий случай").

  **И некоторые другие возможности для удобства работы с объектами в JavaScript...**

------
## Интерфейс программирования - API
### *`refine()`* или *`refinejs()`*
  
> **Основной метод, конструктор объектов.**

  + **Возвращаемое значение**:
  
    *type*: [*object*|*function*] - вернет рабочий объект при вызове метода с оператором **new**, иначе вернет внутренний конструктор (функцию) "***refine-конструктор***".
    
    **Пример:**
	```js
	var foo = new refine(); // вернет готовый объект
	```
	*аналогично выполнению*:
	```js
	var Foo = refine(); // вернет функцию конструктор
	var foo = new Foo(); // вернет готовый объект
	```

#### Параметры конструктора объектов:
  1. [object] - *context*
    - Контекст в котором будет создан ***refine-конструктор*** при условии если задано его имя *cName* 
  2. [string] - *cName*
    - Строка определяющая имя ***refine-конструктора***
  3. [array] - *extend*
    - Массив объектов которые нужно расширить/улучшить или ***refine-конструкторов*** от которых нужно наследоваться.
  4. [object|boolean] - *options*
    - Объект с опциями указывающими об условиях создания объекта, либо true указывающее на то что нужно создать компактный объект, не добавляя лишних свойств, которые нужны для работы библиотеки. 
  5. [object|function] - *structure*
    - Структура создаваемого объекта, если задана функция, то она должна вернуть объект. Функция указывается для реализации Инкапсуляции и получения переданных общих настроек для текущего конструктора.

Примеры
-------

Способ реализации объекта со свойствами, доступными только для чтения:
```js
var Rect = refine(function(left, top, right, bottom) {
  return {
    left: {
      get: function() {
        return left|0;
      }
    },
    top: {
      get: function() {
        return top|0;
      }
    },
    right: {
      get: function() {
        return right|0;
      }
    },
    bottom: {
      get: function() {
        return bottom|0;
      }
    },
    width: {
      get: function() {
        return (right|0) - (left|0);
      }
    },
    height: {
      get: function() {
        return (bottom|0) - (top|0);
      }
    },
  }
});
```
Таким образом, мы имеем конструктор Rect() который создает объект rect со свойствами имеющими атрибут только чтение. Их нельзя переопределить но можно читать. Этот пример иллюстрирует стандартный JavaScript способ реализации *методов доступа*. Но есть более лаконичный и компактный способ:
```js
var Rect = refine(function(left, top, right, bottom) {
  return {
    "get left": left|0,
    "get top": top|0,
    "get right": right|0,
    "get bottom": bottom|0,
    "get width": (right|0) - (left|0),
    "get height": (bottom|0) - (top|0)
  }
});
```
Таким образом что первый что второй вариант, будут работать идентично. И соответственно вызов:
```js
var rect = new Rect(10, 20, 100, 200);

console.log(JSON.stringify(rect));
// в консоль выведет: {"left":10,"top":20,"right":100,"bottom":200,"width":90,"height":180}

// работа с объектом
console.log(rect.width); // 90
rect.width = 40;         // переопределяем свойство
console.log(rect.width); // 90 - переопределить не удалось, значение осталось неизменным
```


Detailed description will be available soon...